package com.typesafe.sbt.jse

import akka.util.Timeout
import com.typesafe.jse.{Node, _}
import com.typesafe.npm.Npm
import com.typesafe.sbt.web.SbtWeb
import sbt.Keys._
import sbt._

import scala.collection.immutable
import scala.concurrent.duration._
import scala.concurrent.{Await, ExecutionContext}
import scala.util.Try

object JsEngineImport {

    object JsEngineKeys {

        object EngineType extends Enumeration {
            val CommonNode, Node, PhantomJs, Javax, Rhino, Trireme,

            /**
              * Auto detect the best available engine to use for most common tasks - this will currently select node if
              * available, otherwise it will fall back to trireme
              */
            AutoDetect = Value
        }

        val command = SettingKey[Option[File]]("jse-command", "An optional path to the command used to invoke the engine.")
        val engineType = SettingKey[EngineType.Value]("jse-engine-type", "The type of engine to use.")
        val parallelism = SettingKey[Int]("jse-parallelism", "The number of parallel tasks for the JavaScript engine. Defaults to the # of available processors + 1 to keep things busy.")

        val npmTimeout = SettingKey[FiniteDuration]("jse-npm-timeout", "The maximum number amount of time for npm to do its thing.")
        val npmNodeModules = TaskKey[Seq[File]]("jse-npm-node-modules", "Node module files generated by NPM.")
    }

}

/**
  * Declares the main parts of a WebDriver based plugin for sbt.
  */
object SbtJsEngine extends AutoPlugin {

    override def requires = SbtWeb

    override def trigger = AllRequirements

    val autoImport = JsEngineImport

    import SbtWeb.autoImport._
    import WebKeys._
    import autoImport._
    import JsEngineKeys._

    /**
      * Convert an engine type enum to an actor props.
      */
    def engineTypeToProps(engineType: EngineType.Value, command: Option[File], env: Map[String, String]) = {
        engineType match {
            case EngineType.CommonNode => CommonNode.props(command, stdEnvironment = env)
            case EngineType.Node => Node.props(command, stdEnvironment = env)
            case EngineType.PhantomJs => PhantomJs.props(command)
            case EngineType.Javax => JavaxEngine.props()
            case EngineType.Rhino => Rhino.props()
            case EngineType.Trireme => Trireme.props(stdEnvironment = env)
            case EngineType.AutoDetect => if (autoDetectNode) {
                Node.props(command, stdEnvironment = env)
            } else {
                Trireme.props(stdEnvironment = env)
            }
        }
    }

    private val NodeModules = "node_modules"
    private val PackageJson = "package.json"


    private lazy val autoDetectNode: Boolean = {
        val nodeExists = Try("node --version".!!).isSuccess
        if (!nodeExists) {
            println("Warning: node.js detection failed, sbt will use the Rhino based Trireme JavaScript engine instead to run JavaScript assets compilation, which in some cases may be orders of magnitude slower than using node.js.")
        }
        nodeExists
    }

    private val jsEngineUnscopedSettings: Seq[Setting[_]] = Seq(
        npmNodeModules := Def.task {
            implicit val timeout = Timeout(npmTimeout.value)
            val npmDirectory = baseDirectory.value / NodeModules
            val npmPackageJson = baseDirectory.value / PackageJson
            val cacheDirectory = streams.value.cacheDirectory / "npm"

            val _state = state.value
            val _command = command.value
            val logger = streams.value.log
            val _webJarsNodeModulesDirectory = (webJarsNodeModulesDirectory in Plugin).value
            val webJarsNodeModulesPath = (webJarsNodeModulesDirectory in Plugin).value.getCanonicalPath
            val _engineType = engineType.value

            val runUpdate = FileFunction.cached(cacheDirectory, FilesInfo.hash) {
                _ =>
                    if (npmPackageJson.exists) {
                        val pendingExitValue = SbtWeb.withActorRefFactory(_state, this.getClass.getName) {
                            arf =>
                                val nodePathEnv = LocalEngine.nodePathEnv(immutable.Seq(webJarsNodeModulesPath))
                                val engineProps = engineTypeToProps(_engineType, _command, nodePathEnv)
                                val engine = arf.actorOf(engineProps)
                                val npm = new Npm(engine, _webJarsNodeModulesDirectory / "npm" / "lib" / "npm.js")
                                import ExecutionContext.Implicits.global
                                for (
                                    result <- npm.update(global = false, Seq("--prefix", baseDirectory.value.getPath))
                                ) yield {
                                    // TODO: We need to stream the output and error channels. The js engine needs to change in this regard so that the
                                    // stdio sink and sources can be exposed through the NPM library and then adopted here.
                                    new String(result.output.toArray, "UTF-8").split("\n").foreach(s => logger.info(s))
                                    new String(result.error.toArray, "UTF-8").split("\n").foreach(s => if (result.exitValue == 0) logger.info(s) else logger.error(s))
                                    result.exitValue
                                }
                        }
                        if (Await.result(pendingExitValue, timeout.duration) != 0) {
                            sys.error("Problems with NPM resolution. Aborting build.")
                        }
                        npmDirectory.allPaths.get.toSet
                    } else {
                        IO.delete(npmDirectory)
                        Set.empty
                    }
            }
            runUpdate(Set(npmPackageJson)).toSeq
        }.dependsOn(webJarsNodeModules in Plugin).value,

        nodeModuleGenerators += npmNodeModules,
        nodeModuleDirectories += baseDirectory.value / NodeModules
    )

    private val defaultEngineType = EngineType.AutoDetect

    override def projectSettings: Seq[Setting[_]] = Seq(
        engineType := sys.props.get("sbt.jse.engineType").fold(defaultEngineType)(engineTypeStr =>
            Try(EngineType.withName(engineTypeStr)).getOrElse {
                println(s"Unknown engine type $engineTypeStr for sbt.jse.engineType. Resorting back to the default of $defaultEngineType.")
                defaultEngineType
            }),
        command := sys.props.get("sbt.jse.command").map(file),
        parallelism := java.lang.Runtime.getRuntime.availableProcessors() + 1,
        npmTimeout := 2.hours

    ) ++ inConfig(Assets)(jsEngineUnscopedSettings) ++ inConfig(TestAssets)(jsEngineUnscopedSettings)

}
